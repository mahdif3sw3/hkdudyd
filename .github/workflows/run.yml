import requests
import os
import re
import base64
import json
import threading
import concurrent.futures
import socket
from datetime import datetime
import random
import string 

# ÛŒÚ© Lock Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ù†Ø¸Ù…â€ŒØªØ±
print_lock = threading.Lock() 

# ÛŒÚ© Set Ø³Ø±Ø§Ø³Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ø´Ù†Ø§Ø³Ù‡â€ŒÙ‡Ø§ÛŒ (Ù‡Ø§Ø³ØªØŒ Ù¾ÙˆØ±ØªØŒ UUID) Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯
seen_identifiers = set() 

# --- ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‡Ø§Ø³ØªØŒ Ù¾ÙˆØ±Øª Ùˆ UUID Ø§Ø² Ú©Ø§Ù†ÙÛŒÚ¯ ---
def extract_host_port_uuid(config_url):
Â Â Â  try:
Â Â Â Â Â Â Â  if config_url.startswith("vless://"):
Â Â Â Â Â Â Â Â Â Â Â  match = re.search(r"vless://([^@]+)@([^:]+):(\d+)", config_url)
Â Â Â Â Â Â Â Â Â Â Â  if match:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  uuid, host, port = match.group(1), match.group(2), int(match.group(3))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return host, port, uuid
Â Â Â Â Â Â Â  elif config_url.startswith("vmess://"):
Â Â Â Â Â Â Â Â Â Â Â  encoded_json = config_url[len("vmess://"):]
Â Â Â Â Â Â Â Â Â Â Â  encoded_json += '=' * (-len(encoded_json) % 4)
Â Â Â Â Â Â Â Â Â Â Â  vmess_data = json.loads(base64.b64decode(encoded_json).decode('utf-8'))
Â Â Â Â Â Â Â Â Â Â Â  host, port, uuid = vmess_data.get('add'), vmess_data.get('port'), vmess_data.get('id')
Â Â Â Â Â Â Â Â Â Â Â  if host and port and uuid:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return host, int(port), uuid
Â Â Â  except Exception:
Â Â Â Â Â Â Â  return None, None, None
Â Â Â  return None, None, None 

def extract_short_source_name(source_link):
Â Â Â  try:
Â Â Â Â Â Â Â  if "raw.githubusercontent.com/" in source_link:
Â Â Â Â Â Â Â Â Â Â Â  return re.search(r"raw\.githubusercontent\.com/([^/]+)/", source_link).group(1)
Â Â Â Â Â Â Â  return re.search(r"https?://(?:www\.)?([^/]+)", source_link).group(1)
Â Â Â  except:
Â Â Â Â Â Â Â  return "Unknown" 

def add_base64_padding(s):
Â Â Â  return s + '=' * (-len(s) % 4) 

def is_base64(s):
Â Â Â  try:
Â Â Â Â Â Â Â  if isinstance(s, str) and re.fullmatch(r"^[A-Za-z0-9+/=\s]+$", s):
Â Â Â Â Â Â Â Â Â Â Â  base64.b64decode(add_base64_padding(s))
Â Â Â Â Â Â Â Â Â Â Â  return True
Â Â Â  except (base64.binascii.Error, UnicodeDecodeError):
Â Â Â Â Â Â Â  pass
Â Â Â  return False 

def get_and_filter_reality_configs(url):
Â Â Â  local_unique_configs = []
Â Â Â  found_in_link_count = 0
Â Â Â  try:
Â Â Â Â Â Â Â  response = requests.get(url, timeout=10)
Â Â Â Â Â Â Â  response.raise_for_status()
Â Â Â Â Â Â Â  content = response.text.strip()
Â Â Â Â Â Â Â  if is_base64(content):
Â Â Â Â Â Â Â Â Â Â Â  try:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  content = base64.b64decode(add_base64_padding(content)).decode('utf-8')
Â Â Â Â Â Â Â Â Â Â Â  except Exception:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  pass
Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â  for line in content.splitlines():
Â Â Â Â Â Â Â Â Â Â Â  line = line.strip()
Â Â Â Â Â Â Â Â Â Â Â  if "security=reality" in line and ("vless://" in line or "vmess://" in line):
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  found_in_link_count += 1
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  host, port, uuid = extract_host_port_uuid(line)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if host and port and uuid:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  identifier = (host, port, uuid)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  with print_lock:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if identifier not in seen_identifiers:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  seen_identifiers.add(identifier)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  local_unique_configs.append({"config": line, "source_link": url, "host": host, "port": port})
Â Â Â Â Â Â Â  return local_unique_configs, found_in_link_count
Â Â Â  except requests.RequestException as e:
Â Â Â Â Â Â Â  with print_lock:
Â Â Â Â Â Â Â Â Â Â Â  print(f"âŒ Error fetching {url}: {e}")
Â Â Â Â Â Â Â  return [], 0 

def tcp_ping(host, port, timeout=2):
Â Â Â  try:
Â Â Â Â Â Â Â  with socket.create_connection((host, port), timeout=timeout):
Â Â Â Â Â Â Â Â Â Â Â  return True
Â Â Â  except Exception:
Â Â Â Â Â Â Â  return False 

links = [
Â Â Â  "https://raw.githubusercontent.com/MhdiTaheri/V2rayCollector/refs/heads/main/sub/vless",
Â Â Â  "https://raw.githubusercontent.com/itsyebekhe/PSG/refs/heads/main/subscriptions/xray/normal/mix",
Â Â Â  "https://raw.githubusercontent.com/T3stAcc/V2Ray/refs/heads/main/All_Configs_Sub.txt",
Â Â Â  "https://raw.githubusercontent.com/SoliSpirit/v2ray-configs/refs/heads/main/Protocols/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/Awmiroosen/awmirx-v2ray/refs/heads/main/blob/main/v2-sub.txt",
Â Â Â  "https://raw.githubusercontent.com/AvenCores/goida-vpn-configs/refs/heads/main/githubmirror/22.txt",
Â Â Â  "https://raw.githubusercontent.com/AvenCores/goida-vpn-configs/refs/heads/main/githubmirror/14.txt",
Â Â Â  "https://raw.githubusercontent.com/MRT-project/v2ray-configs/refs/heads/main/All_Configs_Sub.txt",
Â Â Â  "https://raw.githubusercontent.com/Argh94/v2ray-configs/refs/heads/main/All_Configs_Sub.txt",
Â Â Â  "https://raw.githubusercontent.com/Kolandone/v2raycollector/refs/heads/main/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/gfpcom/free-proxy-list/refs/heads/main/list/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/Surfboardv2ray/TGParse/refs/heads/main/splitted/vless",
Â Â Â  "https://raw.githubusercontent.com/MhdiTaheri/V2rayCollector_Py/refs/heads/main/sub/Mix/mix.txt",
Â Â Â  "https://raw.githubusercontent.com/mheidari98/.proxy/refs/heads/main/vless",
Â Â Â  "https://raw.githubusercontent.com/Leon406/SubCrawler/refs/heads/main/sub/share/vless",
Â Â Â  "https://raw.githubusercontent.com/F0rc3Run/raw-git-freeserver-configs/refs/heads/main/data/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/AzadNetCH/Clash/refs/heads/main/AzadNet.txt",
Â Â Â  "https://raw.githubusercontent.com/xyfqzy/free-nodes/refs/heads/main/nodes/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/thirtysixpw/v2ray-reaper/refs/heads/main/protocol/vless",
Â Â Â  "https://raw.githubusercontent.com/yorkLiu/FreeV2RayNode/refs/heads/main/v2ray.txt",
Â Â Â  "https://raw.githubusercontent.com/Epodonios/v2ray-configs/refs/heads/main/Splitted-By-Protocol/vless.txt",
Â Â Â  "https://raw.githubusercontent.com/barry-far/V2ray-Config/refs/heads/main/All_Configs_Sub.txt",
Â Â Â  "https://raw.githubusercontent.com/lagzian/SS-Collector/refs/heads/main/working.txt"
] 

all_unique_configs = []
with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
Â Â Â  future_to_url = {executor.submit(get_and_filter_reality_configs, link): link for link in links}
Â Â Â  for future in concurrent.futures.as_completed(future_to_url):
Â Â Â Â Â Â Â  unique_configs, _ = future.result()
Â Â Â Â Â Â Â  all_unique_configs.extend(unique_configs) 

print(f"âœ¨ Found {len(all_unique_configs)} unique configs. Now checking their status...") 

working_configs_with_source = []
with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
Â Â Â  future_to_config = {executor.submit(tcp_ping, item['host'], item['port']): item for item in all_unique_configs}
Â Â Â  for future in concurrent.futures.as_completed(future_to_config):
Â Â Â Â Â Â Â  item = future_to_config[future]
Â Â Â Â Â Â Â  if future.result():
Â Â Â Â Â Â Â Â Â Â Â  working_configs_with_source.append(item)
Â Â Â Â Â Â Â Â Â Â Â  print(f"ğŸŸ¢ Active: {item['host']}:{item['port']}")
Â Â Â Â Â Â Â  else:
Â Â Â Â Â Â Â Â Â Â Â  print(f"ğŸ”´ Inactive: {item['host']}:{item['port']}") 

print(f"\nâœ… Found {len(working_configs_with_source)} working configs.") 

final_configs = []
for i, item in enumerate(working_configs_with_source):
Â Â Â  config_url = item["config"].rsplit('#', 1)[0]
Â Â Â  short_name = extract_short_source_name(item["source_link"])
Â Â Â  final_configs.append(f"{config_url}#{i+1} | {short_name}") 

if final_configs:
Â Â Â  all_configs_combined = "\n".join(final_configs)
Â Â Â  base64_encoded_content = base64.b64encode(all_configs_combined.encode('utf-8')).decode('utf-8')
Â Â Â  
Â Â Â  output_dir = "output"
Â Â Â  if not os.path.exists(output_dir):
Â Â Â Â Â Â Â  os.makedirs(output_dir)
Â Â Â  
Â Â Â  secret_name = os.getenv("SECRET_FILENAME_ENV")
Â Â Â  if not secret_name:
Â Â Â Â Â Â Â  print("âš ï¸ Secret filename not found. Using 'default_sub.txt'.")
Â Â Â Â Â Â Â  secret_name = "default_sub.txt"
Â Â Â Â Â Â Â  
Â Â Â  output_filename = os.path.join(output_dir, f"{secret_name}.txt") 

Â Â Â  with open(output_filename, 'w', encoding='utf-8') as f:
Â Â Â Â Â Â Â  f.write(base64_encoded_content)
Â Â Â  print(f"\nğŸ‰ Subscription file saved to '{output_filename}'")
else:
Â Â Â  print("\nğŸ˜¥ No working configs found.")
